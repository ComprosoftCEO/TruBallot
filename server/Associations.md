# Associations System

The API server defines a series of macros in `associations.rs` and `subtypes.rs` to automatically generate Rust code.
This file provides some examples of the code generated by these macros.
The macros are smart enough to automatically import structures from `crate::models::` and any needed traits from [Diesel](https://diesel.rs/).
The `QueryResult` structure is exported by [Diesel](https://docs.diesel.rs/diesel/result/type.QueryResult.html), but can be automatically converted into a `ServiceError`.

Models must derive the following traits to work with the association macros:

- `Serialize` - Can serialize structure from SQL data
- `Queryable` - Can search for structure in the database
- `Insertable` - Can insert structure into the database
- `Identifiable` - Structure contains the primary key
- `AsChangeset` - Indicates a structure can updated the table, omit for fields that are all-key
- `Associations` - Structure stores one or more primary keys

Diesel defines the following attributes:

- `#[table_name]` - Usually not required, but necessary if the table name does not match the structure name
- `#[primary_key]` - Specify the Rust properties in the primary key
- `#[belongs_to]` - Specify that a structure has a foreign key that points to another table

By default, Diesel renames the structures to plural snake case when searching for the database name.
So "PreApprovedEmail" will search for the table "pre_approved_emails".
Additionally, by default foreign keys expect snake case with an ID appended.
So a foreign key from "PreApprovedEmail" to "User" will expect PreApprovedEmail to have a field `user_id` that points to `id` in User.

<br />

## model_base!()

**Usage:**

```rust
model_base!();
model_base!(no update);
model_base!(no update, order by $order);
```

If the `no update` flag is specified, then the `update()` method is not generated.
This should only be used for fields that are all key, such as many-to-many relationships.
If the $order field is specified, then the macro generates additional `get_ordered()` methods; otherwise, these methods are **NOT** generated.

```rust
#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset)]
#[serde(rename_all = "camelCase")]
pub struct LessonPackage {
  pub id: Uuid,
  pub name: String,
  pub description: String,
  pub overview: String,
  pub published: bool,
  pub public: bool,
  pub folder_id: Uuid,
}

impl LessonPackage {
  model_base!(order by lesson_packages::name.asc());
}
```

Expands to:

```rust
impl LessonPackage {
  pub fn all(conn: &DbConnection) -> QueryResult<Vec<Self>> { ... }
  pub fn count_all(conn: &DbConnection) -> QueryResult<i64> { ... }

  // Only generated if $order is specified
  pub fn all_ordered(conn: &DbConnection) -> QueryResult<Vec<Self>> { ... }

  pub fn find(id: &Uuid, conn: &DbConnection) -> QueryResult<Self> { ... }
  pub fn find_optional(id: &Uuid, conn: &DbConnection) -> QueryResult<Option<Self>> { ... }

  pub fn insert(&self, conn: &DbConnection) -> QueryResult<Self> { ... }
  pub fn insert_ignore_conflicts(&self, conn: &DbConnection) -> QueryResult<Option<Self>> { ... }
  pub fn insert_list(entries: &Vec<Self>, conn: &DbConnection) -> QueryResult<Vec<Self>> { ... }
  pub fn insert_list_ignore_conflicts(entries: &Vec<Self>, conn: &DbConnection) -> QueryResult<Vec<Self>> { ... }

  pub fn exists(&self, conn: &DbConnection) -> QueryResult<bool> { ... }
  pub fn exists_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<bool> { ... }

  // Omitted if "no update" flag is specified
  pub fn update(&self, conn: &DbConnection) -> QueryResult<Self> { ... }

  pub fn reload(&mut self, conn: &DbConnection) -> QueryResult<()> { ... }
  pub fn reload_new(&self, conn: &DbConnection) -> QueryResult<Self> { ... }

  pub fn delete(&self, conn &DbConnection) -> QueryResult<Self> { ... }
  pub fn delete_optional(&self, conn &DbConnection) -> QueryResult<Option<Self>> { ... }
  pub fn delete_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<Self> { ... }
  pub fn delete_from_id_optional(id: &Uuid, conn &DbConnection) -> QueryResult<Option<Self>> { ... }
}
```

<br />

## belongs_to!()

**Usage:**

```rust
belongs_to!($struct);
belongs_to!($struct, $func_base);
```

**Parameters:**

- `$struct` - Structure that the foreign key points to
- `$func_base` - Optional, suffix for the function. By default, it converts `$struct` to snake case.

For this macro to work properly, the field needs to define the `#[belongs_to($struct)]` attribute in Diesel.

```rust
#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset, Associations)]
#[belongs_to(LessonPackage)]
#[serde(rename_all = "camelCase")]
pub struct Lesson {
  pub id: Uuid,
  pub lesson_package_id: Uuid,
  pub lesson_number: i32,
  pub title: String,
  pub subtitle: String,
  pub overview: String,
  pub published: bool,
  pub folder_id: Uuid,
}

impl Lesson {
  belongs_to!(LessonPackage);
}
```

Expands to:

```rust
impl Lesson {
  pub fn get_lesson_package(&self, conn: &DbConnection) -> QueryResult<LessonPackage> { ... }
  pub fn get_lesson_package_optional(&self, conn: &DbConnection) -> QueryResult<Option<LessonPackage>> { ... }
}
```

<br />

### has_one!()

**Usage:**

```rust
has_one!($struct);
has_one!($struct, $func_base);
```

**Parameters:**

- `$struct` - Structure that has a foreign key pointing to this structure
- `$func_base` - Optional, suffix for the function. By default, it converts `$struct` to snake case.

For this macro to work properly, the `$struct` needs to define a `#[belongs_to(Structure)]` that points back to this structure.
The `has_one!()` macro is a special case of a one-to-many relationship that only expects one item.

```rust
#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset, Associations)]
#[serde(rename_all = "camelCase")]
pub struct Field {
  pub id: Uuid,
  pub name: String,
}

#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset, Associations)]
#[belongs_to(Field, foreign_key = "field_identifier")]
#[serde(rename_all = "camelCase")]
pub struct FieldChild {
  pub id: i32,
  pub field_identifier: Uuid,
}

impl Field {
  has_one!(FieldChild, my_field_child);
}
```

Expands to:

```rust
impl Field {
  pub fn get_my_field_child(&self, conn: &DbConnection) -> QueryResult<FieldChild> { ... }
  pub fn get_my_field_child_from_id(id: &i32, conn: &DbConnection) -> QueryResult<FieldChild> { ... }

  pub fn delete_my_field_child(&self, conn: &DbConnection) -> QueryResult<FieldChild> { ... }
  pub fn delete_my_field_child_from_id(id: &i32, conn: &DbConnection) -> QueryResult<FieldChild> { ... }
}
```

<br />

## has_zero_or_one!()

**Usage:**

```rust
has_zero_or_one!($struct);
has_zero_or_one!($struct, $func_base);
```

**Parameters:**

- `$struct` - Structure that has a foreign key pointing to this structure
- `$func_base` - Optional, suffix for the function. By default, it converts `$struct` to snake case.

For this macro to work properly, the `$struct` needs to define a `#[belongs_to(Structure)]` that points back to this structure.
The `has_zero_or_one!()` macro is a special case of a one-to-many relationship that only expects zero or one item.
This macro is often used with subtypes to get the child object.

```rust
#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset, Associations)]
#[belongs_to(Company)]
#[serde(rename_all = "camelCase")]
pub struct AccessCode {
  pub id: Uuid,
  pub email: String,
  pub company_id: Uuid,
  pub duration: DateInterval,
  pub expires_at: NaiveDateTime,
}

#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset, Associations)]
#[primary_key(subscription_id)]
#[belongs_to(Subscription)]
#[belongs_to(AccessCode)]
#[serde(rename_all = "camelCase")]
pub struct AccessCodeSubscription {
  pub subscription_id: Uuid,
  pub access_code_id: Uuid,
}

impl AccessCode {
  has_zero_or_one!(AccessCodeSubscription);
}
```

Expands to:

```rust
impl AccessCode {
  pub fn get_access_code_subscription(&self, conn: &DbConnection) -> QueryResult<Option<AccessCodeSubscription>> { ... }
  pub fn get_access_code_subscription_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<Option<AccessCodeSubscription>> { ... }

  pub fn delete_access_code_subscription(&self, conn: &DbConnection) -> QueryResult<Option<AccessCodeSubscription>> { ... }
  pub fn delete_access_code_subscription_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<Option<AccessCodeSubscription>> { ... }
}
```

<br />

## has_many!()

**Usage:**

```rust
has_many!($struct);
has_many!($struct, order by $order);
has_many!($struct, $func_base);
has_many!($struct, order by $order, $func_base);
```

**Parameters:**

- `$struct` - Structure that has a foreign key pointing to this structure
- `$order` - Optional, if specified uses the Diesel field for the order
- `$func_base` - Optional, suffix for the function. By default, it converts `$struct` to snake case and pluralized by adding a `s` to the end.

For this macro to work properly, the `$struct` needs to define a `#[belongs_to(Structure)]` that points back to this structure.
If the $order field is specified, then the macro generates additional `get_ordered()` methods; otherwise, these methods are **NOT** generated.

```rust
#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset, Associations)]
#[belongs_to(LessonPackage)]
#[serde(rename_all = "camelCase")]
pub struct Lesson {
  pub id: Uuid,
  pub lesson_package_id: Uuid,
  pub lesson_number: i32,
  pub title: String,
  pub subtitle: String,
  pub overview: String,
  pub published: bool,
  pub folder_id: Uuid,
}

#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset, Associations)]
#[belongs_to(Lesson)]
#[serde(rename_all = "camelCase")]
pub struct LessonPage {
  pub id: Uuid,
  pub lesson_id: Uuid,
  pub page_number: i32,
  pub title: String,
  pub content: String,
  pub published: bool,
}

impl Lesson {
  has_many!(LessonPage, order by lesson_pages::page_number.asc());
}
```

**Expands to:**

```rust
impl Lesson {
  pub fn get_lesson_pages(&self, conn: &DbConnection) -> QueryResult<Vec<LessonPage>> { ... }
  pub fn get_lesson_pages_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<Vec<LessonPage>> { ... }

  pub fn count_lesson_pages(&self, conn: &DbConnection) -> QueryResult<i64> { ... }
  pub fn count_lesson_pages_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<i64> { ... }

  pub fn delete_all_lesson_pages(&self, conn: &DbConnection) -> QueryResult<Vec<LessonPage>> { ... }
  pub fn delete_all_lesson_pages_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<Vec<LessonPage>> { ... }

  // Only generated if $order is specified
  pub fn get_lesson_pages_ordered(&self, conn: &DbConnection) -> QueryResult<Vec<LessonPage>> { ... }
  pub fn get_lesson_pages_ordered_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<Vec<LessonPage>> { ... }
}
```

<br />

## has_many!(through)

**Usage:**

```rust
has_many!($struct through $through);
has_many!($struct through $through, order by $order);
has_many!($struct through $through, $func_base);
has_many!($struct through $through, order by $order, $func_base);
```

**Parameters:**

- `$struct` - Structure that has a foreign key pointing to the `$through` field
- `$through` - Intermediate field in the many-to-many relationship. It has foreign keys that point to `$struct` and `$through`.
- `$order` - Optional, if specified uses the Diesel field for the order
- `$func_base` - Optional, suffix for the function. By default, it converts `$struct` to snake case and pluralized by adding a `s` to the end.

This macro is used to define a many-to-many relationship betweeen fields.
For this association to work properly, the `$through` field needs to implement the `ManyManyConstructor` trait:

```rust
/// Trait that must be implemented to construct a many-to-many relationship
pub trait ManyToManyConstructor<Left, Right>: BelongsTo<Left> + BelongsTo<Right> {
  fn new(left: &<Self as BelongsTo<Left>>::ForeignKey, right: &<Self as BelongsTo<Right>>::ForeignKey) -> Self;
}
```

For example:

```rust
#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, Associations)]
#[primary_key(user_id)]
#[belongs_to(User)]
#[serde(rename_all = "camelCase")]
pub struct Administrator {
  pub user_id: Uuid,
}

#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, Associations)]
#[primary_key(administrator_id, role_id)]
#[belongs_to(Administrator)]
#[belongs_to(Role)]
#[serde(rename_all = "camelCase")]
pub struct AdministratorRole {
  pub administrator_id: Uuid,
  pub role_id: i32,
}

#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset)]
#[serde(rename_all = "camelCase")]
pub struct Role {
  pub id: i32,
  pub name: String,
  pub description: String,
}

impl Administrator {
  has_many!(Role through AdministratorRole, order by roles::name.asc());
}

impl ManyToManyConstructor<Administrator, Role> for AdministratorRole {
  fn new(administrator_id: &Uuid, role_id: &i32) -> Self {
    Self::new(*administrator_id, *role_id)
  }
}

impl ManyToManyConstructor<Role, Administrator> for AdministratorRole {
  fn new(role_id: &i32, administrator_id: &Uuid) -> Self {
    Self::new(*administrator_id, *role_id)
  }
}
```

Expands to:

```rust
impl Administrator {
  pub fn get_roles(&self, conn: &DbConnection) -> QueryResult<Vec<Role>> { ... }
  pub fn get_roles_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<Vec<Role>> { ... }

  pub fn count_roles(&self, conn: &DbConnection) -> QueryResult<i64> { ... }
  pub fn count_roles_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<i64> { ... }

  // These methods delete children from many-to-many the association.
  // DO NOT delete the actual values from the database!
  pub fn remove_all_roles(&self, conn: &DbConnection) -> QueryResult<Vec<AdministratorRole>> { ... }
  pub fn remove_all_roles_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<Vec<AdministratorRole>> { ... }

  pub fn set_roles<'a>(&self, list: IntoIterator<Item = &'a Role>, conn: &DbConnection) -> QueryResult<Vec<AdministratorRole>> { ... }
  pub fn set_roles_ids<'a>(&self, list: IntoIterator<Item = &'a i32>, conn: &DbConnection) -> QueryResult<Vec<AdministratorRole>> { ... }
  pub fn set_roles_from_id<'a>(id: &Uuic, list: IntoIterator<Item = &'a Role>, conn: &DbConnection) -> QueryResult<Vec<AdministratorRole>> { ... }
  pub fn set_roles_ids_from_id<'a>(id: &Uuic, list: IntoIterator<Item = &'a i32>, conn: &DbConnection) -> QueryResult<Vec<AdministratorRole>> { ... }

  // Only generated if $order is specified
  pub fn get_roles_ordered(&self, conn: &DbConnection) -> QueryResult<Vec<Role>> { ... }
  pub fn get_roles_ordered_from_id(id: &Uuid, conn: &DbConnection) -> QueryResult<Vec<Role>> { ... }
}
```

<br />

## parent_type!()

**Usage:**

```rust
parent_type!($type = $field)
parent_type!($type = $field, $func_base);
```

**Parameters:**

- `$type` - Data type for the child discriminant
- `$field` - Struct field that stores the discriminant type
- `$func_base` - Optional, suffix for the function. By default, it converts `$type` to snake case.

```rust
#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset, Associations)]
#[belongs_to(User)]
#[serde(rename_all = "camelCase")]
pub struct Subscription {
  pub id: Uuid,
  pub user_id: Uuid,
  pub subscription_type: SubscriptionType,
  pub start: NaiveDate,
}

sql_enum!(
  pub SubscriptionType {
    Paid = 1,       // Subscription purchased with a credit card
    AccessCode,     // Activated by an access code
  }
);

impl Subscription {
  parent_type!(SubscriptionType = subscription_type);
}
```

Expands to:

```rust
impl Subscription {
  pub fn get_subscription_type(&self) -> SubscriptionType { ... }
}
```

<br />

## child_type!()

**Usage:**

```rust
child_type!($parent_struct, $type = $value);
child_type!($parent_struct, $type = $value, $func_base);
```

**Parameters:**

- `$parent_struct` - Parent structure that this field points to
- `$type` - Data type for the discriminant
- `$value` - Expected value for the child discriminant
- `$func_base` - Optional, suffix for the function. By default, it converts `$type` to snake case.

```rust
#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset, Associations)]
#[belongs_to(User)]
#[serde(rename_all = "camelCase")]
pub struct Subscription {
  pub id: Uuid,
  pub user_id: Uuid,
  pub subscription_type: SubscriptionType,
  pub start: NaiveDate,
}

#[derive(Debug, Clone, Serialize, Queryable, Insertable, Identifiable, AsChangeset, Associations)]
#[primary_key(subscription_id)]
#[belongs_to(Subscription)]
#[belongs_to(AccessCode)]
#[serde(rename_all = "camelCase")]
pub struct AccessCodeSubscription {
  pub subscription_id: Uuid,
  pub access_code_id: Uuid,
}

sql_enum!(
  pub SubscriptionType {
    Paid = 1,       // Subscription purchased with a credit card
    AccessCode,     // Activated by an access code
  }
);

impl AccessCodeSubscription {
  child_type!(Subscription, SubscriptionType = SubscriptionType::AccessCode);
}
```

Expands to:

```rust
impl AccessCodeSubscription {
  pub fn get_subscription_type(&self) -> SubscriptionType { ... }

  pub fn get_parent(&self, conn: &DbConnection) -> QueryResult<Subscription> { ... }
  pub fn get_parent_optional(&self, conn: &DbConnection) -> QueryResult<Option<Subscription>> { ... }
}
```
